\newcommand{\diagram}{\textcolor{red}{(picture coming soon)}}

\chapter{RVWMO Explanatory Material}
\label{sec:explanation}
This section provides more explanation for the RVWMO memory model, using more informal language and concrete examples.
These are intended to clarify the meaning and intent of the axioms and preserved program order rules.
%In case of any discrepancy between the informal descriptions here and the formal descriptions elsewhere, the formal definitions should be considered authoritative.

\section{Why RVWMO?}
\label{sec:whynottso}

Memory consistency models fall along a loose spectrum from weak to strong.
Weak memory models allow more hardware implementation flexibility and deliver arguably better performance, performance per watt, power, scalability, and hardware verification overheads than strong models, at the expense of a more complex programming model.
Strong models provide simpler programming models, but at the cost of imposing more restrictions on the kinds of (non-speculative) hardware optimizations that can be performed in the pipeline and in the memory system, and in turn imposing some cost in terms of power, area overhead, and verification burden.

RISC-V has chosen the RVWMO memory model, which is a variant of release consistency.
This places it in between the two extremes of the memory model spectrum.
The RVWMO memory model enables architects to build simple implementations, aggressive implementations, implementations embedded deeply inside a much larger system and subject to complex memory system interactions, or any number of other possibilities, all while simultaneously being strong enough to support programming language memory models at high performance.

To facilitate the porting of code from other architectures, some hardware implementations may choose to implement the Ztso extension, which provides stricter RVTSO ordering semantics by default.
Code written for RVWMO is automatically and inherently compatible with RVTSO, but code written assuming RVTSO is not guaranteed to run correctly on RVWMO implementations.
In fact, most RVWMO implementations will (and should) simply refuse to run RVTSO-only binaries.
Each implementation must therefore choose whether to prioritize compatibility with RVTSO code (e.g., to facilitate porting from x86) or whether to instead prioritize compatibility with other RISC-V cores implementing RVWMO.

Some fences and/or memory ordering annotations in code written for RVWMO may become redundant under RVTSO; the cost that the default of RVWMO imposes on Ztso implementations is the incremental overhead of fetching those fences (e.g., {\tt fence~r,rw} and {\tt fence rw,w}) which become no-ops on that implementation.
However, these fences must remain present in the code if compatibility with non-Ztso implementations is desired.

\section{Litmus Tests}
The explanations in this chapter make use of {\em litmus tests}, or small programs designed to test or highlight one particular aspect of a memory model.
Figure~\ref{fig:litmus:sample} shows an example of a litmus test with two harts.
As a convention for this figure and for all figures that follow in this chapter, we assume that {\tt s0}--{\tt s2} are pre-set to the same value in all harts and that {\tt s0} holds the address labeled {\tt x}, {\tt s1} holds {\tt y}, and {\tt s2} holds {\tt z}, where {\tt x}, {\tt y}, and {\tt z} are different memory addresses.
This figure shows the same program twice: on the left in RISC-V assembly, and again on the right in graphical form.

\begin{figure}[h!]
  \centering
  {
    \tt\small
    \begin{tabular}{cl||cl}
    \multicolumn{2}{c}{Hart 0} & \multicolumn{2}{c}{Hart 1} \\
    \hline
          & $\vdots$    &     & $\vdots$    \\
          & li t1,1     &     & li t4,4     \\
      (a) & sw t1,0(s0) & (e) & sw t4,0(s0) \\
          & $\vdots$    &     & $\vdots$    \\
          & li t2,2     &     &             \\
      (b) & sw t2,0(s0) &     &             \\
          & $\vdots$    &     & $\vdots$    \\
      (c) & lw a0,0(s0) &     &             \\
          & $\vdots$    &     & $\vdots$    \\
          & li t3,3     &     & li t5,5     \\
      (d) & sw t3,0(s0) & (f) & sw t5,0(s0) \\
          & $\vdots$    &     & $\vdots$    \\
    \end{tabular}
  }
  ~~~~
  \diagram
  \caption{A sample litmus test}
  \label{fig:litmus:sample}
\end{figure}

Litmus tests are used to understand the implications of the memory model in specific concrete situations.
For example, in the litmus test of Figure~\ref{fig:litmus:sample}, the final value of {\tt a0} in the first hart can be either 2, 4, or 5, depending on the dynamic interleaving of the instruction stream from each hart at runtime.
However, in this example, the final value of {\tt a0} in Hart 0 will never be 1 or 3; intuitively, the value 1 will no longer be visible at the time the load executes, and the value 3 will not yet be visible by the time the load executes.

We analyze this test and many others below.

\section{Explaining the RVWMO Rules}
In this section, we provide explanation and examples for all of the RVWMO rules and axioms.

\subsection{Preserved Program Order and Global Memory Order}
Preserved program order represents the set of intra-hart orderings that the hart's pipeline must ensure are maintained as the instructions execute, even in the presence of hardware optimizations that might otherwise reorder those operations.
Events from the same hart which are not ordered by preserved program order, on the other hand, may appear reordered from the perspective of other harts and/or observers.

Informally, the global memory order represents the order in which loads and stores perform.
The formal memory model literature has moved away from specifications built around the concept of performing, but the idea is still useful for building up informal intuition.
A load is said to have performed when its return value is determined.
A store is said to have performed not when it has executed inside the pipeline, but rather only when its value has been propagated to globally visible memory.
In this sense, the global memory order also represents the contribution of the coherence protocol and/or the rest of the memory system to interleave the (possibly reordered) memory accesses being issued by each hart into a single total order agreed upon by all harts.

The order in which loads perform does not always directly correspond to the relative age of the values those two loads return.
In particular, a load $b$ may perform before another load $a$ to the same address (i.e., $b$ may execute before $a$, and $b$ may appear before $a$ in the global memory order), but $a$ may nevertheless return an older value than $b$.
This discrepancy captures (among other things) the reordering effects of buffering placed between the core and memory.
For example, $b$ may have returned a value from a store in the store buffer, while $a$ may have ignored that younger store and read an older value from memory instead.
To account for this, at the time each load performs, the value it returns is determined by the load value axiom, not just strictly by determining the most recent store to the same address in the global memory order, as described below.

\subsection{Load Value Axiom}
\label{sec:memory:loadvalueaxiom}
\begin{tabular}{p{1cm}|p{12cm}} &
Load Value Axiom:\loadvalueaxiom
\end{tabular}

Preserved program order is {\em not} required to respect the ordering of a store followed by a load to an overlapping address.
This complexity arises due to the ubiquity of store buffers in nearly all implementations.
Informally, the load may perform (return a value) by forwarding from the store while the store is still in the store buffer, and hence before the store itself performs (writes back to globally visible memory).
Any other hart will therefore observe the load as performing before the store.

\begin{figure}[h!]
  \centering
  {
    \tt\small
    \begin{tabular}{cl||cl}
    \multicolumn{2}{c}{Hart 0} & \multicolumn{2}{c}{Hart 1} \\
    \hline
          & li t1, 1    &     & li t1, 1    \\
      (a) & sw t1,0(s0) & (e) & sw t1,0(s1) \\
      (b) & lw a0,0(s0) & (f) & lw a2,0(s1) \\
      (c) & fence r,r   & (g) & fence r,r   \\
      (d) & lw a1,0(s1) & (h) & lw a3,0(s0) \\
    \end{tabular}
  }
  ~~~~
  \diagram
  \caption{A store buffer forwarding litmus test}
  \label{fig:litmus:storebuffer}
\end{figure}

Consider the litmus test of Figure~\ref{fig:litmus:storebuffer}.
When running this program on an implementation with store buffers, it is possible to arrive at the final outcome
{\tt a0=1}, {\tt a1=0}, {\tt a2=1}, {\tt a3=0}
as follows:
\begin{itemize}
  \item (a) executes and enters the first hart's private store buffer
  \item (b) executes and forwards its return value 1 from (a) in the store buffer
  \item (c) executes since all previous loads (i.e., (b)) have completed
  \item (d) executes and reads the value 0 from memory
  \item (e) executes and enters the second hart's private store buffer
  \item (f) executes and forwards its return value 1 from (d) in the store buffer
  \item (g) executes since all previous loads (i.e., (f)) have completed
  \item (h) executes and reads the value 0 from memory
  \item (a) drains from the first hart's store buffer to memory
  \item (e) drains from the second hart's store buffer to memory
\end{itemize}
Therefore, the memory model must be able to account for this behavior.

To put it another way, suppose the definition of preserved program order did include the following hypothetical rule:
memory access $a$ precedes memory access $b$ in preserved program order (and hence also in the global memory order) if $a$ precedes $b$ in program order and $a$ and $b$ are accesses to the same memory location, $a$ is a write, and $b$ is a read.  Call this ``Rule X''.  Then we get the following:

\begin{itemize}
  \item (a) precedes (b): by rule X
  \item (b) precedes (d): by rule \ref{ppo:fence}
  \item (d) precedes (e): by the load value axiom.  Otherwise, if (e) preceded (d), then (d) would be required to return the value 1.  (This is a perfectly legal execution; it's just not the one in question)
  \item (e) precedes (f): by rule X
  \item (f) precedes (h): by rule \ref{ppo:fence}
  \item (h) precedes (a): by the load value axiom, as above.
\end{itemize}
The global memory order must be a total order and cannot be cyclic, because a cycle would imply that every event in the cycle happens before itself, which is impossible.
Therefore, the execution proposed above would be forbidden, and hence the addition of rule X would break the memory model.

Nevertheless, even if (b) precedes (a) and/or (f) precedes (e) in the global memory order, the only sensible possibility in this example is for (b) to return the value written by (a), and likewise for (f) and (e).  This combination of circumstances is what leads to the second option in the definition of the load value axiom.
Even though (b) precedes (a) in the global memory order, (a) will still be visible to (b) by virtue of sitting in the store buffer at the time (b) executes.
Therefore, even if (b) precedes (a) in the global memory order, (b) should return the value written by (a) because (a) precedes (b) in program order.
Likewise for (e) and (f).

\subsection{Atomicity Axiom}
\label{sec:memory:atomicityaxiom}
\begin{tabular}{p{1cm}|p{12cm}} &
  Atomicity Axiom for Aligned Atomics: \atomicityaxiom
\end{tabular}

The RISC-V architecture decouples the notion of atomicity from the notion of ordering.  Unlike architectures such as TSO, RISC-V atomics under RVWMO do not impose any ordering requirements by default.  Ordering semantics are only guaranteed by the PPO rules that otherwise apply.

RISC-V contains two types of atomics: AMOs and LR/SC pairs.
These conceptually behave differently, in the following way.
LR/SC behave as if the old value is brought up to the core, modified, and written back to memory, all while a reservation is held on that memory location.
AMOs on the other hand conceptually behave as if they are performed directly in memory.
AMOs are therefore inherently atomic, while LR/SC pairs are atomic in the slightly different sense that the memory location in question will not be modified by another hart during the time the original hart holds the reservation.

\begin{figure}[h!]
  \centering\small
  \begin{verbbox}
  (a) lr.d t0, 0(a0)
  (b) sd   t1, 0(a0)
  (c) sc.d t2, 0(a0)
  \end{verbbox}
  \theverbbox
%  \caption{Store-conditional (c) may succeed on some implementations}
%  \label{fig:litmus:lrsdsc}
%\end{figure}
%
%\begin{figure}[h!]
%  \centering\small
  ~~~~~~~~~~~~~~~~
  \begin{verbbox}
  (a) lr.d t0, 0(a0)
  (b) sd   t1, 4(a0)
  (c) sc.d t2, 0(a0)
  \end{verbbox}
  \theverbbox
%  \caption{Store-conditional (c) may succeed on some implementations}
  \caption{In both code snippets, the store-conditional (c) may succeed on some implementations}
  \label{fig:litmus:lrsdsc}
\end{figure}

The atomicity axiom does not forbid loads from being interleaved between the paired operations in program order or in the global memory order, nor does it forbid stores from the same hart from appearing between the paired operations in either program order or in the global memory order.
For example, the sequences in Figure~\ref{fig:litmus:lrsdsc} are legal, and the {\tt sc} instructions may (but are not guaranteed to) succeed.
%By preserved program order rule \ref{ppo:->st}, the program order of the three operations must be maintained in the global memory order.
This does not violate the atomicity axiom, because the intervening non-conditional store is from the same hart as the paired load-reserved and store-conditional instructions.
This way, a memory system that tracks memory accesses at cache line granularity (and which therefore will see the two snippets of Figure~\ref{fig:litmus:lrsdsc} as identical) will not be forced to fail a store conditional instruction that happens to (falsely) share another portion of the same cache line as the memory location being held by the reservation.

\subsection{Progress Axiom}
\label{sec:progress}
\begin{tabular}{p{1cm}|p{12cm}}
  & Progress Axiom: \progressaxiom
\end{tabular}

The progress axiom ensures a minimal forward progress guarantee.
It ensures that stores from one hart will eventually be made visible to other harts in the system in a finite amount of time, and that loads from other harts will eventually be able to read those values (or successors thereof).
Without this rule, it would be legal, for example, for a spinlock to spin infinitely on a value, even with a store from another hart waiting to unlock the spinlock.

The progress axiom is intended not to impose any other notion of fairness, latency, or quality of service onto the harts in a RISC-V implementation.
Any stronger notions of fairness are up to the rest of the ISA and/or up to the platform to define and implement.

The forward progress axiom will in almost all cases be naturally satisfied by any standard cache coherence protocol.
Implementations with non-coherent caches may have to provide some other mechanism to ensure the eventual visibility of all stores (or successors thereof) to all harts.

\subsection{Overlapping-Address Orderings (Rules~\ref{ppo:->st}--\ref{ppo:amoforward})}
\label{sec:memory:overlap}
\begin{tabular}{p{1cm}|p{12cm}}
  & Rule \ref{ppo:->st}: \ppost \\
  & Rule \ref{ppo:rdw}: \ppordw \\
  & Rule \ref{ppo:amoforward}: \ppoamoforward \\
\end{tabular}

Same-address orderings where the latter is a store are straightforward: a load or store can never be reordered with a later store to an overlapping memory location.  From a microarchitecture perspective, generally speaking, it is difficult or impossible to undo a speculatively reordered store if the speculation turns out to be invalid, so such behavior is simply disallowed by the model.
Same-address orderings from a store to a later load, on the other hand, do not need to be enforced.
As discussed in Section~\ref{sec:memory:loadvalueaxiom}, this reflects the observable behavior of implementations that forward values from buffered stores to later loads.

Same-address load-load ordering requirements are far more subtle.
The basic requirement is that a younger load must not return a value which is older than a value returned by an older load in the same hart to the same address.  This is often known as ``CoRR'' (Coherence for Read-Read pairs), or as part of a broader ``coherence'' or ``sequential consistency per location'' requirement.
Some architectures in the past have relaxed same-address load-load ordering, but in hindsight this is generally considered to complicate the programming model too much, and so RVWMO requires CoRR ordering to be enforced.
However, because the global memory order corresponds to the order in which loads perform rather than the ordering of the values being returned, capturing CoRR requirements in terms of the global memory order requires a bit of indirection.

\begin{figure}[h!]
  \center
  {
    \tt\small
    \begin{tabular}{cl||cl}
    \multicolumn{2}{c}{Hart 0} & \multicolumn{2}{c}{Hart 1} \\
    \hline
          & li t1, 1    &     & li~ t2, 2    \\
      (a) & sw t1,0(s0) & (d) & lw~ a0,0(s1) \\
      (b) & fence w, w  & (e) & sw~ t2,0(s1) \\
      (c) & sw t1,0(s1) & (f) & lw~ a1,0(s1) \\
          &             & (g) & xor t3,a1,a1 \\
          &             & (h) & add s0,s0,t3 \\
          &             & (i) & lw~ a2,0(s0) \\
    \end{tabular}
  }
  ~~~~
  \diagram
  \caption{Litmus test MP+FENCE+fri-rfi-addr}
  \label{fig:litmus:frirfi}
\end{figure}

Consider the litmus test of Figure~\ref{fig:litmus:frirfi}, which is one particular instance of the more general ``fri-rfi'' pattern.
The term ``fri-rfi'' refers to the sequence (d), (e), (f): (d) ``from-reads'' (i.e., reads from an earlier write than) (e) which is the same hart, and (f) reads from (e) which is in the same hart.

From a microarchitectural perspective, outcome {\tt a0=1}, {\tt a1=2}, {\tt a2=0} is legal (as are various other less subtle outcomes).  Intuitively, the following would produce the outcome in question:
\begin{itemize}
  \item (d) stalls (for whatever reason; perhaps it's stalled waiting for some other preceding instruction)
  \item (e) executes and enters the store buffer (but does not yet drain to memory)
  \item (f) executes and forwards from (e) in the store buffer
  \item (g), (h), and (i) execute
  \item (a) executes and drains to memory, (b) executes, and (c) executes and drains to memory
  \item (d) unstalls and executes
  \item (e) drains from the store buffer to memory
\end{itemize}
This corresponds to a global memory order of (f), (i), (a), (c), (d), (e).
Note that even though (f) performs before (d), the value returned by (f) is newer than the value returned by (d).
Therefore, this execution is legal and does not violate the CoRR requirements.

Likewise, if two back-to-back loads return the values written by the same store, then they may also appear out-of-order in the global memory order without violating CoRR.  Note that this is not the same as saying that the two loads return the same value, since two different stores may write the same value.

\begin{figure}[h!]
  \centering
  {
    \tt\small
    \begin{tabular}{cl||cl}
    \multicolumn{2}{c}{Hart 0} & \multicolumn{2}{c}{Hart 1} \\
    \hline
          & li t1, 1    & (d) & lw~ a0,0(s1) \\
      (a) & sw t1,0(s0) & (e) & xor t2,a0,a0 \\
      (b) & fence w, w  & (f) & add s2,s2,t2 \\
      (c) & sw t1,0(s1) & (g) & lw~ a1,0(s2) \\
          &             & (h) & lw~ a2,0(s2) \\
          &             & (i) & xor t3,a2,a2 \\
          &             & (j) & add s0,s0,t3 \\
          &             & (k) & lw~ a3,0(s0) \\
    \end{tabular}
  }
  ~~~~
  \diagram
  \caption{Litmus test RSW}
  \label{fig:litmus:rsw}
\end{figure}

Consider the litmus test of Figure~\ref{fig:litmus:rsw}.
The outcome {\tt a0=1}, {\tt a1=a2}, {\tt a3=0} can be observed by allowing (g) and (h) to be reordered.  This might be done speculatively, and the speculation can be justified by the microarchitecture (e.g., by snooping for cache invalidations and finding none) because replaying (h) after (g) would return the value written by the same store anyway.
Hence assuming {\tt a1} and {\tt a2} would end up with the same value written by the same store anyway, (g) and (h) can be legally reordered.
The global memory order corresponding to this execution would be (h),(k),(a),(c),(d),(g).

Executions of the test in Figure~\ref{fig:litmus:rsw} in which {\tt a1} does not equal {\tt a2} do in fact require that (g) appears before (h) in the global memory order.
Allowing (h) to appear before (g) in the global memory order would in that case result in a violation of CoRR, because then (h) would return an older value than that returned by (g).
Therefore, PPO rule~\ref{ppo:rdw} forbids this CoRR violation from occurring.
As such, PPO rule~\ref{ppo:rdw} strikes a careful balance between enforcing CoRR in all cases while simultaneously being weak enough to permit ``RSW'' and ``fri-rfi'' patterns that commonly appear in real microarchitectures.

There is one more overlapping-address rule for AMOs.
PPO rule~\ref{ppo:amoforward} simply states that a value cannot be returned from an AMO to a subsequent load until the AMO has performed globally.
This follows naturally from the conceptual view that AMOs are performed directly in memory (See Section~\ref{sec:memory:atomicityaxiom}), except possibly for the case of {\tt amoswap}.
Rule~\ref{ppo:amoforward} states that hardware may not non-speculatively forward the value being stored by the {\tt amoswap} to a subsequent load, even though for {\tt amoswap} that store value is not actually semantically dependent on the previous value in memory, as is the case for the other AMOs.

The three PPO rules above also apply when the memory accesses in question only overlap partially.
This can occur, for example, when accesses of different sizes are used to access the same object.
Note also that the base addresses of two overlapping memory operations need not necessarily be the same for two memory accesses to overlap.
When misaligned memory accesses are being used, the overlapping-address PPO rules apply to each of the component memory accesses independently.

\begin{comment}
The formal model captures this as follows:
\begin{itemize}
  \item (a) precedes (b) in preserved program order because both are stores to the same address, and (b) is a store (Rule~\ref{ppo:->st}).  Therefore, (c) cannot return the value written by (a), because (b) is a later store to the same address in both program order and the global memory order, and so returning the value written by (a) would violate the load value axiom.
  \item (c) precedes (d) in preserved program order because both are accesses to the same address, and (d) is a store.  (c) also precedes (d) in program order.  Therefore, (c) is not able to return the value written by (d), because neither option in the load value axiom applies.
\end{itemize}
\end{comment}

\subsection{Fences (Rule~\ref{ppo:fence})}\label{sec:mm:fence}
\begin{tabular}{p{1cm}|p{12cm}} &
Rule \ref{ppo:fence}: \ppofence
\end{tabular}

By default, the {\tt fence} instruction ensures that all memory accesses from instructions preceding the fence in program order (the ``predecessor set'') appear earlier in the global memory order than memory accesses from instructions appearing after the fence in program order (the ``successor set'').
However, fences can optionally further restrict the predecessor set and/or the successor set to  a smaller set of memory accesses in order to provide some speedup.
Specifically, fences have {\tt .pr}, {\tt .pw}, {\tt .sr}, and {\tt .sw} bits which restrict the predecessor and/or successor sets.
The predecessor set includes loads (resp.\@ stores) if and only if {\tt .pr} (resp.\@ {\tt .pw}) is set.
Similarly, the successor set includes loads (resp.\@ stores) if and only if {\tt .sr} (resp.\@ {\tt .sw}) is set.

The {\tt fence} encoding currently has nine non-trivial combinations of the four bits {\tt pr}, {\tt pw}, {\tt sr}, and {\tt sw}, plus one extra encoding ``{\tt fence.tso}'' which is expected to be added to facilitate mapping of ``acquire+release'' or RVTSO semantics.
The remaining seven combinations have empty predecessor and/or successor sets and hence are no-ops.
Of the ten non-trivial options, only six are commonly used in practice:
{\tt
\begin{itemize}
  \item fence rw,rw
  \item fence.tso \textrm{(i.e., a combined {\tt fence r,rw} $+$ {\tt fence rw,w})}
  \item fence rw,w
  \item fence r,rw
  \item fence r,r
  \item fence w,w
\end{itemize}
}
{\tt fence} instructions using any other combination of {\tt .pr}, {\tt .pw}, {\tt .sr}, and {\tt .sw} are reserved.  We strongly recommend that programmers stick to these six.
Other combinations may have unknown or unexpected interactions with the memory model.

Finally, we note that since RISC-V uses a multi-copy atomic memory model, programmers can reason about fences bits in a thread-local manner.  There is no complex notion of ``fence cumulativity'' as found in memory models which are not multi-copy atomic.

\subsection{Acquire/Release Ordering (Rules~\ref{ppo:acquire}--\ref{ppo:rcsc})}\label{sec:acqrel}
\begin{tabular}{p{1cm}|p{12cm}}
  & Rule \ref{ppo:acquire}: \ppoacquire \\
  & Rule \ref{ppo:release}: \pporelease \\
  & Rule \ref{ppo:rcsc}: \pporcsc \\
\end{tabular}

An {\em acquire} operation, as would be used at the start of a critical section, requires all memory operations following the acquire in program order to also follow the acquire in the global memory order.
This ensures, for example, that all loads and stores inside the critical section are up to date with respect to the synchronization variable being used to protect it.
Acquire ordering can be enforced in one of two ways: with an acquire annotation, which enforces ordering with respect to just the synchronization variable itself, or with a {\tt fence r,rw}, which enforces ordering with respect to all previous loads.  

\begin{figure}[h!]
  \centering\small
  \begin{verbatim}
          sd           x1, (a1)     # Random unrelated store
          ld           x2, (a2)     # Random unrelated load
          li           t0, 1        # Initialize swap value.
      again:
          amoswap.w.aq t0, t0, (a0) # Attempt to acquire lock.
          bnez         t0, again    # Retry if held.
          # ...
          # Critical section.
          # ...
          amoswap.w.rl x0, x0, (a0) # Release lock by storing 0.
          sd           x3, (a3)     # Random unrelated store
          ld           x4, (a4)     # Random unrelated load
  \end{verbatim}
  \caption{A spinlock with atomics}
  \label{fig:litmus:spinlock_atomics}
\end{figure}

Consider Figure~\ref{fig:litmus:spinlock_atomics}.
Because this example uses {\tt .aq}, the loads and stores in the critical section are guaranteed to appear in the global memory order after the {\tt amoswap} used to acquire the lock.  However, assuming {\tt a0}, {\tt a1}, and {\tt a2} point to different memory locations, the loads and stores in the critical section may or may not appear after the ``random unrelated load'' at the beginning of the example in the global memory order.

\begin{figure}[h!]
  \centering\small
  \begin{verbatim}
          sd           x1, (a1)     # Random unrelated store
          ld           x2, (a2)     # Random unrelated load
          li           t0, 1        # Initialize swap value.
      again:
          amoswap.w    t0, t0, (a0) # Attempt to acquire lock.
          fence        r, rw        # Enforce "acquire" memory ordering
          bnez         t0, again    # Retry if held.
          # ...
          # Critical section.
          # ...
          fence        rw, w        # Enforce "release" memory ordering
          amoswap.w    x0, x0, (a0) # Release lock by storing 0.
          sd           x3, (a3)     # Random unrelated store
          ld           x4, (a4)     # Random unrelated load
  \end{verbatim}
  \caption{A spinlock with fences}
  \label{fig:litmus:spinlock_fences}
\end{figure}

Now, consider the alternative in Figure~\ref{fig:litmus:spinlock_fences}.
In this case, even though the {\tt amoswap} does not enforce ordering with an {\tt .aq} bit, the fence nevertheless enforces that the acquire {\tt amoswap} appears earlier in the global memory order than all loads and stores in the critical section.
Note, however, that in this case, the fence also enforces additional orderings: it also requires that the ``random unrelated load'' at the start of the program appears also appears earlier in the global memory order than the loads and stores of the critical section.  (This particular fence does not, however, enforce any ordering with respect to the ``random unrelated store'' at the start of the snippet.)
In this way, fence-enforced orderings are slightly coarser than orderings enforced by {\tt.aq}.

Release orderings work exactly the same as acquire orderings, just in the opposite direction.  Release semantics require all loads and stores preceding the release operation in program order to also precede the release operation in the global memory order.
This ensures, for example, that memory accesses in a critical section appear before the lock-releasing store in the global memory order.  Just as for acquire semantics, release semantics can be enforced using release annotations or with a {\tt fence rw,w} operations.  Using the same examples, the ordering between the loads and stores in the critical section and the ``random unrelated store'' at the end of the code snippet is enforced only by the {\tt fence rw,w} in Figure~\ref{fig:litmus:spinlock_fences}, not by the {\tt .rl} in Figure~\ref{fig:litmus:spinlock_fences}.

With RCpc annotations alone, store-release-to-load-acquire ordering is not enforced.  This facilitates the porting of code written under the TSO and/or RCpc memory models.  
To enforce store-release-to-load-acquire ordering, the code must use store-release-RCsc and load-acquire-RCsc operations so that PPO rule \ref{ppo:rcsc} applies.
RCpc alone is sufficient for many uses cases in C/C++ but is insufficient for many other use cases in C/C++, Java, and Linux, to name just a few examples; see Section~\ref{sec:porting} for details.

Lastly, we note that just as with fences, programmers need not worry about ``cumulativity'' when analyzing ordering annotations.

\subsection{Syntactic Dependencies (Rules~\ref{ppo:addr}--\ref{ppo:ctrl})}
\label{sec:depspart1}
\begin{tabular}{p{1cm}|p{12cm}}
  & Rule \ref{ppo:addr}: \ppoaddr \\
  & Rule \ref{ppo:data}: \ppodata \\
  & Rule \ref{ppo:ctrl}: \ppoctrl \\
\end{tabular}

Dependencies from a load to a later memory operation in the same hart are respected by the RVWMO memory model.
The Alpha memory model was notable for choosing {\em not} to enforce the ordering of such dependencies, but most modern hardware and software memory models consider allowing dependent instructions to be reordered too confusing and counterintuitive.
Furthermore, modern code sometimes intentionally uses such dependencies as a particularly lightweight ordering enforcement mechanism.

The terms in Section~\ref{sec:deps} work as follows.
Instructions are said to carry dependencies from their source register(s) to their destination register(s) whenever the value written into each destination register is a function of the source register(s).
For most instructions, this means that the destination register(s) carry a dependency from all source register(s).
However, there are a few notable exceptions.
In the case of memory instructions, the value written into the destination register ultimately comes from the memory system rather than from the source register(s) directly, and so this breaks the chain of dependencies carried from the source register(s).
In the case of indirect jumps, the value written into the destination register comes from the current {\tt pc} (which is never considered a source register by the memory model), and so likewise, indirect jumps do not carry a dependency from the source register(s) to the destination register.

\begin{verbbox}
(a) fadd  f3,f1,f2
(b) fadd  f6,f4,f5
(c) csrrs a0,fflags,x0
\end{verbbox}
\begin{figure}[h!]
  \centering\small
  \theverbbox
  \caption{(c) has a syntactic dependency on both (a) and (b) via {\tt fflags}, a destination register which both (a) and (b) implicitly accumulate into}
  \label{fig:litmus:fflags}
\end{figure}

The notion of accumulating into a destination register rather than writing into it reflects the behavior of CSRs such as {\tt fflags}.
In particular, an accumulation into a register does not clobber any previous writes or accumulations into the same register.
For example, in Figure~\ref{fig:litmus:fflags}, (c) has a syntactic dependency on both (a) and (b).

Like other modern memory models, the RVWMO memory model uses syntactic rather than semantic dependencies.
In other words, this definition depends on the identities of the
registers being accessed by different instructions, not the actual
contents of those registers.  This means that an address, control, or
data dependency must be enforced even if the calculation could seemingly
be ``optimized away''.
This choice ensures that RVWMO remains compatible with code that uses these false syntactic dependencies as a lightweight ordering mechanism.

\begin{verbbox}
ld  a1,0(s0)
xor a2,a1,a1
add s1,s1,a2
ld  a5,0(s1)
\end{verbbox}
\begin{figure}[h!]
  \centering\small
  \theverbbox
  \caption{A syntactic address dependency}
  \label{fig:litmus:address}
\end{figure}

For example, there is a syntactic address
dependency from the memory operation generated by the first instruction to the memory operation generated by the last instruction in
Figure~\ref{fig:litmus:address}, even though {\tt a1} XOR {\tt a1} is zero and
hence has no effect on the address accessed by the second load.

The benefit of using dependencies as a lightweight synchronization mechanism is that the ordering enforcement requirement is limited only to the specific two instructions in question.
Other non-dependent instructions may be freely-reordered by aggressive implementations.
One alternative would be to use a load-acquire, but this would enforce ordering for the first load with respect to {\em all} subsequent instructions.
Another would be to use a {\tt fence r,r}, but this would include all previous and all subsequent loads, making this option more expensive.

\begin{verbbox}
      lw  x1,0(x2)
      bne x1,x0,NEXT
      sw  x3,0(x4)
next: sw  x5,0(x6)
\end{verbbox}
\begin{figure}[h!]
  \centering\small
  \theverbbox
  \caption{A syntactic control dependency}
  \label{fig:litmus:control1}
\end{figure}

Control dependencies behave differently from address and data dependencies in the sense that a control dependency always extends to all instructions following the original target in program order.
Consider Figure~\ref{fig:litmus:control1}: the instruction at {\tt next} will always execute, but memory operation generated by that last instruction nevertheless still has control dependency from the memory operation generated by the first instruction.

\begin{verbbox}
        lw  x1,0(x2)
        bne x1,x0,NEXT
  next: sw  x3,0(x4)
\end{verbbox}
\begin{figure}[h!]
  \centering\small
  \theverbbox
  \caption{Another syntactic control dependency}
  \label{fig:litmus:control2}
\end{figure}

Likewise, consider Figure~\ref{fig:litmus:control2}.
Even though both branch outcomes have the same target, there is still a control dependency from the memory operation generated by the first instruction in this snippet to the memory operation generated by the last instruction.
This definition of control dependency is subtly stronger than what might be seen in other contexts (e.g., C++), but it conforms with standard definitions of control dependencies in the literature.

Notably, PPO rules \ref{ppo:addr}--\ref{ppo:ctrl} are also intentionally designed to respect dependencies which originate from the output of a successful store conditional instruction.
In general, an {\tt sc} instruction will be followed by a branch checking whether the outcome was successful; this implies that there will be a control dependency from the store operation generated by the {\tt sc} instruction to any memory operations following the branch.
PPO rule~\ref{ppo:ctrl} in turn implies that any subsequent store operations will appear later in the global memory order than the store operation generated by the {\tt sc}.
However, a dependency cannot originate or be used to enforce ordering from the {\em rd} destination register of an unsuccessful {\tt sc} instruction.

\begin{figure}[h!]
  \center
  {
    \tt\small
    \begin{tabular}{cl||cl}
    \multicolumn{2}{c}{Hart 0} & \multicolumn{2}{c}{Hart 1} \\
    \hline
      (a) & ld a0,0(s0)    & (e) & ld a3,0(s2) \\
      (b) & lr a1,0(s1)    & (f) & sd a3,0(s0) \\
      (c) & sc a2,a0,0(s1) &                    \\
      (d) & sd a2,0(s2)    &                    \\
    \end{tabular}
  }
  ~~~~
  \diagram
  \caption{A variant of the LB litmus test}
  \label{fig:litmus:successdeps}
\end{figure}

In addition, the choice to respect dependencies originating at store-conditional instructions ensures that certain out-of-thin-air-like behaviors will be prevented.
Consider Figure~\ref{fig:litmus:successdeps}.
Suppose a hypothetical implementation could occasionally make some early guarantee that a store-conditional operation will succeed.
In this case, (c) could return 0 to {\tt a2} early (before actually executing), allowing the sequence (d), (e), (f), (a), and then (b) to execute, and then (c) might execute (successfully) only at that point.
This would imply that (c) writes its own success value to {\tt 0(s1)}!
Fortunately, this situation and others like it are prevented by the fact that RVWMO respects dependencies originating at the stores generated by successful {\tt sc} instructions.

\subsection{Pipeline Dependencies (Rules~\ref{ppo:addrdatarfi}--\ref{ppo:addrpo})}
\label{sec:ppopipeline}
\begin{tabular}{p{1cm}|p{12cm}}
  & Rule \ref{ppo:addrdatarfi}: \ppoaddrdatarfi \\
  & Rule \ref{ppo:addrpo}: \ppoaddrpo \\
%  & Rule \ref{ppo:ctrlcfence}: \ppoctrlcfence \\
%  & Rule \ref{ppo:addrpocfence}: \ppoaddrpocfence \\
\end{tabular}

\begin{figure}[h!]
  \centering
  {
    \tt\small
    \begin{tabular}{cl}
      (a) & lw a0, 0(s0)   \\
      (b) & sw a0, 0(s1)   \\
      (c) & lw a1, 0(s1)   \\
    \end{tabular}
  }
  ~~~~
  \diagram
  \caption{Because of the data dependency from (a) to (b), (a) also precedes (c)}
  \label{fig:litmus:addrdatarfi}
\end{figure}

PPO rules~\ref{ppo:addrdatarfi} and \ref{ppo:addrpo} reflect behaviors of almost all real processor pipeline implementations.
Rule~\ref{ppo:addrdatarfi} states that a load forward from a store until the address and data for that store are known.
Consider Figure~\ref{fig:litmus:addrdatarfi}:
(c) cannot be executed until the data for (b) has been resolved, because (c) must return the value written by (b) (or by something even later in the global memory order), and the old value must not be clobbered by the writeback of (b) before (a) has had a chance to perform.  Therefore, (c) will never perform before (a) has performed.

\begin{figure}[h!]
  \centering
  {
    \tt\small
    \begin{tabular}{cl}
          & li t1, 1       \\
      (a) & lw a0, 0(s0)   \\
      (b) & sw a0, 0(s1)   \\
          & sw t1, 0(s1)   \\
      (c) & lw a1, 0(s1)   \\
    \end{tabular}
  }
  ~~~~
  \diagram
  \caption{Because of the extra store between (b) and (c), (a) no longer necessarily precedes (c)}
  \label{fig:litmus:addrdatarfi_no}
\end{figure}

If there were another store to the same address in between (b) and (c), as in Figure~\ref{fig:litmus:addrdatarfi_no}, then (c) would no longer be dependent on the data of (b) being resolved, and hence the dependency of (c) on (a), which produces the data for (b), would be broken.

Rule~\ref{ppo:addrpo} makes a similar observation to the previous rule: a store cannot be performed at memory until all previous loads which might access the same address have themselves been performed.
Such a load must appear to execute before the store, but it cannot do so if the store were to overwrite the value in memory before the load had a chance to read the old value.

\begin{figure}[h!]
  \centering
  {
    \tt\small
    \begin{tabular}{cl}
        & li t1, 1       \\
    (a) & lw a0, 0(s0)   \\
    (b) & lw a1, 0(a0)   \\
    (c) & sw t1, 0(s1)   \\
    \end{tabular}
  }
  ~~~~
  \diagram
  \caption{Because of the address dependency from (a) to (b), (a) also precedes (c)}
  \label{fig:litmus:addrpo}
\end{figure}

Consider Figure~\ref{fig:litmus:addrpo}:
(c) cannot be executed until the address for (b) is resolved, because it may turn out that the addresses match; i.e., that {\tt a0=s1}.  Therefore, (c) cannot be sent to memory before (a) has executed and confirmed whether the addresses to indeed overlap.


\section{Beyond Normal Memory}

In this section, we provide an informal description of how the {\tt fence.i}, {\tt sfence.vma}, I/O fences, and PMAs interact with the memory model.

Instruction fetches and address translation operations (where applicable) informally follow the RISC-V memory model as well as the rules below.
\begin{itemize}
  \item {\tt fence.i}: Conceptually, {\tt fence.i} ensures that the fetch of each instruction following the {\tt fence.i} in program order appears later in the global memory order than all stores prior to the {\tt fence.i} in program order.
    That in turn means that instruction caches which hardware does not keep coherent with normal memory must be invalidated when a {\tt fence.i} instruction is executed.
  \item {\tt sfence.vma}: Conceptually, the address translation operations of each instruction following the {\tt sfence.vma} in program order appear later in the global memory order than all stores prior to the {\tt sfence.vma} in program order.
    This implies that stale entries in the local hart's TLBs must be invalidated.
  \item Conceptually, updates to the page table made by a hardware page table walker must be atomic, in the sense of obeying the Atomicity Axiom (or stronger)
\end{itemize}

\subsection{Coherence and Cacheability}

The RISC-V Privileged ISA defines Physical Memory Attributes (PMAs) which specify, among other things, whether portions of the address space are coherent and/or cacheable.
See the RISC-V Privileged ISA Specification for the complete details.
Here, we simply discuss how the various details in each PMA relate to the memory model:

\begin{itemize}
  \item Main memory vs.\@ I/O, and I/O memory ordering PMAs: the memory model as defined applies to main memory regions.  I/O ordering is discussed below.
  \item Supported access types and atomicity PMAs: the memory model is simply applied on top of whatever primitives each region supports.
  \item Cacheability PMAs: the cacheability PMAs in general do not affect the memory model.  Non-cacheable regions may have more restrictive behavior than cacheable regions, but the set of allowed behaviors does not change regardless.  However, some platform-specific cacheability settings may differ.
  \item Coherence PMAs: The memory consistency model for memory regions marked as non-coherent in PMAs is currently platform-specific: the load-value axiom, the atomicity axiom, and the progress axiom all may be violated with non-coherent memory.  Note however that coherent memory does not require a hardware cache coherence protocol.  The RISC-V Privileged ISA Specification suggests that hardware-incoherent regions of main memory are discouraged, but the memory model is compatible with hardware coherence, software coherence, implicit coherence due to read-only memory, implicit coherence due to only one agent having access, or otherwise.
  \item Idempotency PMAs: Idempotency PMAs are used to specify memory regions for which loads and/or stores may have side effects, and this in turn is used by the microarchitecture to determine, e.g., whether prefetches are legal.  This distinction does not affect the memory model.
\end{itemize}


\subsection{I/O Ordering}

For I/O, the load value axiom and atomicity axiom in general do not apply, as both reads and writes might have device-specific side effects and may return values other than the value ``written'' by the most recent store to the same address.
Nevertheless, the following preserved program order rules still generally apply for accesses to I/O memory:
memory access $a$ precedes memory access $b$ in global memory order if $a$ precedes $b$ in program order and one or more of the following holds:
\begin{enumerate}
  \item $a$ precedes $b$ in preserved program order as defined in Section~\ref{sec:memorymodel}, with the exception that acquire and release ordering annotations apply only from one memory operation to another memory operation and from one I/O operation to another I/O operation, but not from a memory operation to an I/O nor vice versa
  \item $a$ and $b$ are accesses to overlapping addresses in an I/O region
  \item $a$ and $b$ are accesses to the same strongly-ordered I/O region
  \item $a$ and $b$ are accesses to I/O regions, and the channel associated with the I/O region accessed by either $a$ or $b$ is channel 1
  \item $a$ and $b$ are accesses to I/O regions associated with the same channel (except for channel 0)
\end{enumerate}

Note that the {\tt fence} instruction distinguishes between memory operations and I/O operations in its predecessor and successor sets.
To enforce ordering between I/O operations and memory operations, code must use a {\tt fence} with {\tt .pi}, {\tt .po}, {\tt .si}, and/or {\tt .so}, plus {\tt .pr}, {\tt .pw}, {\tt .sr}, and/or {\tt .sw}.
For example, to enforce ordering between a write to normal memory and an MMIO write to a device register, a {\tt FENCE w,o} or stronger is needed.

\begin{verbbox}
  sd t0, 0(a0)
  fence w,o
  sd a0, 0(a1)
\end{verbbox}
\begin{figure}[h!]
  \centering\small
  \theverbbox
  \caption{Ordering memory and I/O accesses}
  \label{fig:litmus:wo}
\end{figure}

When a fence is in fact used, implementations must assume that the device may attempt to access memory immediately after receiving the MMIO signal, and subsequent memory accesses from that device to memory must observe the effects of all accesses ordered prior to that MMIO operation.
In other words, in Figure~\ref{fig:litmus:wo}, suppose {\tt 0(a0)} is in normal memory and {\tt 0(a1)} is the address of a device register in I/O memory.
If the device accesses {\tt 0(a0)} upon receiving the MMIO write, then that load must conceptually appear after the first store to {\tt 0(a0)} according to the rules of the RVWMO memory model.
In some implementations, the only way to ensure this will be to require that the first store does in fact complete before the MMIO write is issued.
Other implementations may find ways to be more aggressive, while others still may not need to do anything different at all for I/O and normal memory accesses.
Nevertheless, the RVWMO memory model does not distinguish between these options; it simply provides an implementation-agnostic mechanism to specify the orderings that must be enforced.

Many architectures include separate notions of ``ordering'' and ``completion'' fences, especially as it relates to I/O (as opposed to normal memory).
Ordering fences simply ensure that memory operations stay in order, while completion fences ensure that predecessor accesses have all completed before any successors are made visible.
RISC-V does not explicitly distinguish between ordering and completion fences.
Instead, this distinction is simply inferred from different uses of the FENCE bits.

For implementations that conform to the RISC-V Unix Platform Specification, I/O devices and DMA operations are required to access memory coherently and via strongly-ordered I/O channels.
Therefore, accesses to normal memory regions that are shared with I/O devices can also use the standard synchronization mechanisms.
Implementations which do not conform to the Unix Platform Specification and/or in which devices do not access memory coherently will need to use mechanisms (which are currently platform-specific) to enforce coherency.

I/O regions in the address space should be considered non-cacheable regions in the PMAs for those regions.  Such regions can be considered coherent by the PMA if they are not cached by any agent.

The ordering guarantees in this section may not apply beyond a platform-specific boundary between the RISC-V cores and the device.  In particular, I/O accesses sent across an external bus (e.g., PCIe) may be reordered before they reach their ultimate destination.  Ordering must be enforced in such situations according to the platform-specific rules of those external devices and buses.

\section{Code Porting Guidelines}
\label{sec:porting}

Normal x86 loads and stores are all inherently acquire-RCpc and release-RCpc operations: TSO enforces all load-load, load-store, and store-store ordering by default.
All TSO loads must be mapped onto {\tt l\{b|h|w|d\}; fence r,rw}, and all TSO stores must either be mapped onto {\tt amoswap.rl x0} or onto {\tt fence rw,w; s\{b|h|w|d\}}.
%Alternatively, TSO loads and stores can be mapped onto {\tt l\{b|h|w|d\}.aq} and {\tt s\{b|h|w|d\}.rl} assembler pseudoinstructions to facilitate forwards compatibility in case such instructions are added to the ISA one day.
%However, in the meantime, the assembler will generate the same fence-based and/or {\tt amoswap}-based versions for these pseudoinstructions.
x86 atomics using the LOCK prefix are all sequentially consistent and when ported naively to RISC-V must be marked as {\tt .aqrl}.

A Power {\tt sync}/{\tt hwsync} fence, an ARM {\tt dmb} fence, and an x86 {\tt mfence} are all equivalent to a RISC-V {\tt fence rw,rw}.
Power {\tt isync} and ARM {\tt isb} map to RISC-V {\tt fence.i; fence r,r}; the latter fence is needed because {\tt isync} and {\tt isb} are used to define a {\em control+control fence} dependency that is not present in RVWMO.
A Power {\tt lwsync} map onto {\tt fence.tso}, or onto either {\tt fence rw,rw} or {\tt fence rw,w; fence r,r} when {\tt fence.tso} is not available.
ARM {\tt dmb ld} and {\tt dmb st} fences map to RISC-V {\tt fence r,rw} and {\tt fence w,w}, respectively.

Since RISC-V does not currently have {\tt l\{b|h|w|d\}.aq[rl]} or  {\tt s\{b|h|w|d\}.[aq]rl} opcodes, ARM load-acquire and store-release operations should be mapped onto {\tt l\{b|h|w|d\}; fence r,rw} and {fence rw,w; \tt s\{b|h|w|d\}}, respectively.

Note however that there is a small incompatibility between the ARMv8 memory model and RVWMO: ARMv8 also forbids forwarding of values from a successful store conditional instruction to a subsequent load-acquire instruction.
Therefore, strict theoretical compatibility with the ARMv8 memory model requires either that all ARM store-conditional instructions map to {\tt sc.aqrl} or that ARM load-acquire operations map to {\tt fence rw,rw; l\{b|h|w|d\}; fence r,rw} (i.e., with the leading {\tt fence rw,rw}).
However, in practice, the software requirement that this ARMv8 rule is intended to address is covered instead by other RVWMO properties; namely, the fact that all paired operations are data-dependent and the fact that AMOs behave as a single operation.
It should therefore generally be safe to elide this latter strict compatibility requirement.

The Linux fences {\tt smp\_mb()}, {\tt smp\_wmb()}, {\tt smp\_rmb()} map onto {\tt fence rw,rw}, {\tt fence w,w}, and {\tt fence r,r}, respectively.
%The now-deprecated fence {\tt smp\_read\_barrier\_depends()} map to a no-op due to preserved program order rules \ref{ppo:addr}--\ref{ppo:ctrl}.
The Linux fences {\tt dma\_rmb()} and {\tt dma\_wmb()} map onto {\tt fence r,r} and {\tt fence w,w}, respectively, since the RISC-V Unix Platform requires coherent DMA.
The Linux fences {\tt rmb()}, {\tt wmb()}, and {\tt mb()} map onto {\tt fence ri,ri}, {\tt fence wo,wo}, and {\tt fence rwio,rwio}, respectively.

Linux acquire atomic operations can be implemented either by following the relevant AMO or LR/SC pair with a {\tt fence r,rw} or by using an AMO with {\tt .aq} set.
Linux release atomic operations can be implemented either by preceding the relevant AMO or LR/SC pair with a {\tt fence rw,w} or by using an AMO with {\tt .rl} set.
Linux fully-ordered atomic operations can be implemented by both preceding the relevant AMO or LR/SC pair with a {\tt fence rw,w} and following the relevant AMO or LR/SC pair with a {\tt fence rw,rw}, by using an AMO with both {\tt .aq} and {\tt .rl} set, or by using an LR/SC pair where the LR has {\tt .aq} set and the SC has both {\tt .aq} and {\tt .rl} set.

\begin{table}[h!]
  \begin{tabular}{|l|l|}
    \hline
    C/C++ Construct                            & RVWMO Mapping \\
    \hline
    \hline
    Non-atomic load                            & \tt l\{b|h|w|d\}               \\
    \hline
    \tt atomic\_load(memory\_order\_relaxed)   & \tt l\{b|h|w|d\}               \\
    \hline
    %\tt atomic\_load(memory\_order\_consume)   & \multicolumn{2}{l|}{\tt l\{b|h|w|d\}; fence r,rw}   \\
    %\hline
    \tt atomic\_load(memory\_order\_acquire)   & \tt l\{b|h|w|d\}; fence r,rw    \\
    \hline
    \tt atomic\_load(memory\_order\_seq\_cst)  & \tt fence rw,rw; l\{b|h|w|d\}; fence r,rw       \\
    \hline
    \hline
    Non-atomic store                           & \tt s\{b|h|w|d\}               \\
    \hline
    \tt atomic\_store(memory\_order\_relaxed)  & \tt s\{b|h|w|d\}               \\
    \hline
    \tt atomic\_store(memory\_order\_release)  & \tt fence rw,w; s\{b|h|w|d\}  \\
    \hline
    \tt atomic\_store(memory\_order\_seq\_cst) & \tt fence rw,rw; s\{b|h|w|d\} \\
    \hline
    \hline
    \tt atomic\_thread\_fence(memory\_order\_acquire)  & \tt fence r,rw \\
    \hline
    \tt atomic\_thread\_fence(memory\_order\_release)  & \tt fence rw,w \\
    \hline
    \tt atomic\_thread\_fence(memory\_order\_acq\_rel) & {\tt fence.tso} or {\tt fence rw,w; fence r,r} \\
    \hline
    \tt atomic\_thread\_fence(memory\_order\_seq\_cst) & \tt fence rw,rw \\
    \hline
  \end{tabular}
  \caption{Mappings from C/C++ primitives to RISC-V primitives.}
  \label{tab:mappings}
\end{table}

The C11/C++11 {\tt memory\_order\_*} primitives should be mapped as shown in Table~\ref{tab:mappings}.

The acquire-RCsc annotation can be emulated via fences by following the relevant AMO or LR/SC pair with a {\tt fence r,rw}.
The release-RCsc can be emulated via fences by preceding the relevant AMO or LR/SC pair with a {\tt fence rw,w}.
A combined acquire-RCsc and release-RCsc annotation can be emulated via fences by both preceding the relevant AMO or LR/SC pair with a {\tt fence rw,w} and following the relevant AMO or LR/SC pair with a {\tt fence rw,rw}.

Any AMO can be emulated by an LR/SC pair, but care must be taken to ensure that any PPO orderings that originate from the LR are also made to originate from the SC, and that any PPO orderings which terminate at the SC are also made to terminate at the LR.
For example, the LR must also be made to respect any data dependencies that the AMO has, given that load operations do not otherwise have any notion of a data dependency.
Likewise, the effect a {\tt fence r,r} elsewhere in the thread must also be made to apply to the SC, which would not otherwise respect that fence.
In the general case, this will require preceding the relevant AMO or LR/SC pair with a {\tt fence rw,w} and following the relevant AMO or LR/SC pair with a {\tt fence rw,rw}.
However, this requirement is likely overkill for many software requirements that would have been satisfied just using an LR/SC pair to begin with.

\section{Implementation Guidelines}

The RVWMO and RVTSO memory models by no means preclude microarchitectures from employing sophisticated speculation techniques or other forms of optimization in order to deliver higher performance.
The models also do not impose any requirement to use any one particular cache hierarchy, nor even to use a cache coherence protocol at all.
Instead, these models only specify the behaviors that can be exposed to software.
Microarchitectures are free to use any pipeline design, any coherent or non-coherent cache hierarchy, any on-chip interconnect, etc., as long as the design satisfies the memory model rules.
That said, to help people understand the actual implementations of the memory model, in this section we provide some guidelines below on how architects and programmers should interpret the models' rules.

Both RVWMO and RVTSO are multi-copy atomic (or ``other-multi-copy-atomic''): any store value which is visible to a hart other than the one that originally issued it must also be conceptually visible to all other harts in the system.
In other words, harts may forward from their own previous stores before those stores have become globally visible to all harts, but no early inter-hart forwarding is permitted.
Multi-copy atomicity may be enforced in a number of ways.
It might hold inherently due to the physical design of the caches and store buffers, it may be enforced via a single-writer/multiple-reader cache coherence protocol, or it might hold due to some other mechanism.

Although multi-copy atomicity does impose some restrictions on the microarchitecture, it is one of the key properties keeping the memory model from becoming extremely complicated.
For example, a hart may not legally forward a value from a neighbor hart's private store buffer, unless those two harts are the only two in the system.
Nor may a cache coherence protocol forward a value from one hart to another until the coherence protocol has invalidated all older copies from other caches.
Of course, microarchitectures may (and high-performance implementations likely will) violate these rules under the covers through speculation or other optimizations, as long as any non-compliant behaviors are not exposed to the programmer.

As a rough guideline for interpreting the PPO rules in RVWMO, we expect the following from the software perspective:
\begin{itemize}
  \item programmers will use PPO rules \ref{ppo:->st} and \ref{ppo:fence}--\ref{ppo:rcsc} regularly and actively.
  \item expert programmers will use PPO rules \ref{ppo:addr}--\ref{ppo:ctrl} to speed up critical paths of important data structures.
  \item even expert programmers will rarely if ever use PPO rules \ref{ppo:rdw}--\ref{ppo:amoforward} and \ref{ppo:addrdatarfi}--\ref{ppo:addrpo} directly.  These are included to facilitate common microarchitectural optimizations (rule~\ref{ppo:rdw}) and the operational formal modeling approach (rules \ref{ppo:amoforward} and \ref{ppo:addrdatarfi}--\ref{ppo:addrpo}) described in Section~\ref{sec:operational}.  They also facilitate the process of porting code from other architectures which have similar rules.
\end{itemize}

We also expect the following from the hardware perspective:
\begin{itemize}
  \item PPO rules \ref{ppo:->st} and \ref{ppo:amoforward}--\ref{ppo:release} reflect well-understood rules that should pose few surprises to architects.
  \item PPO rule \ref{ppo:rdw} reflects a natural and common hardware optimization, but one that is very subtle and hence is worth double checking carefully.
  \item PPO rule \ref{ppo:rcsc} may not be immediately obvious to architects, but it is a standard memory model requirement
  \item The load value axiom, the atomicity axiom, and PPO rules \ref{ppo:addr}--\ref{ppo:addrpo} reflect rules that most hardware implementations will enforce naturally, unless they contain extreme optimizations.  Of course, implementations should make sure to double check these rules nevertheless.  Hardware must also ensure that syntactic dependencies are not ``optimized away''.
\end{itemize}

Architectures are free to implement any of the memory model rules as conservatively as they choose.  For example, a hardware implementation may choose to do any or all of the following:
  \begin{itemize}
    \item interpret all fences as if they were {\tt fence rw,rw} (or {\tt fence iorw,iorw}, if I/O is involved), regardless of the bits actually set
    \item implement all fences with {\tt .pw} and {\tt .sr} as if they were {\tt fence~rw,rw} (or {\tt fence~iorw,iorw}, if I/O is involved), as ``{\tt w,r}'' is the most expensive of the four possible normal memory orderings anyway
    \item ignore any addresses passed to a fence instruction and simply implement the fence for all addresses
    \item emulate {\tt .aq} and {\tt .rl} as described in Section~\ref{sec:porting}
    \item enforcing all same-address load-load ordering, even in the presence of patterns such as ``fri-rfi'' and ``RSW''
    \item forbid any forwarding of a value from a store in the store buffer to a subsequent AMO or {\tt lr} to the same address
    \item forbid any forwarding of a value from an AMO or {\tt sc} in the store buffer to a subsequent load to the same address
    \item implement TSO on all memory accesses, and ignore any normal memory fences that do not include ``{\tt w,r}'' ordering (e.g., as Ztso implementations will do)
    \item implement all atomics to be RCsc or even fully-ordered, regardless of annotation
  \end{itemize}

Architectures which implement RVTSO can safely do the following:
\begin{itemize}
  \item Ignore all fences which do not have both {\tt .pw} and {\tt .sr} (unless the fence also orders I/O)
  \item Ignore all PPO rules except for rules \ref{ppo:fence} and \ref{ppo:rcsc}, since the rest are redundant with other PPO rules under RVTSO assumptions
\end{itemize}

Other general notes:

\begin{itemize}
  \item Silent stores (i.e., stores which write the same value that already exists at a memory location) do not have any special behavior from a memory model point of view.  Microarchitectures that attempt to implement silent stores must take care to ensure that the memory model is still obeyed, particularly in cases such as RSW (Section~\ref{sec:memory:overlap}) which tend to be incompatible with silent stores.
  \item Writes may be merged (i.e., two consecutive writes to the same address may be merged) or subsumed (i.e., the earlier of two back-to-back writes to the same address may be elided) as long as the resulting behavior does not otherwise violate the memory model semantics.
\end{itemize}

The question of write subsumption can be understood from the following example:
\begin{figure}[h!]
  \centering
  {
    \tt\small
    \begin{tabular}{cl||cl}
    \multicolumn{2}{c}{Hart 0} & \multicolumn{2}{c}{Hart 1} \\
    \hline
        & li t1, 3    &     & li  t3, 2    \\
        & li t2, 1    &     &              \\
    (a) & sw t1,0(s0) & (d) & lw  a0,0(s1) \\
    (b) & fence w, w  & (e) & sw  a0,0(s0) \\
    (c) & sw t2,0(s1) & (f) & lw  t3,0(s0) \\
    \end{tabular}
  }
  ~~~~
  \diagram
  \caption{Write subsumption litmus test}
  \label{fig:litmus:subsumption}
\end{figure}

As written, (a) must precede (f) in the global memory order:
\begin{itemize}
  \item (a) precedes (c) in the global memory order because of rule 2
  \item (c) precedes (d) in the global memory order because of the Load Value axiom
  \item (d) precedes (e) in the global memory order because of rule 7
  \item (e) precedes (f) in the global memory order because of rule 1
\end{itemize}

A very aggressive microarchitecture might erroneously decide to discard (e), as (f) supersedes it, and this may in turn lead the microarchitecture to break the now-eliminated dependency between (d) and (f) (and hence also between (a) and (f)).
This would violate the memory model rules, and hence it is forbidden.
Write subsumption may in other cases be legal, if for example there were no data dependency between (d) and (e).

\subsection{Possible Future Extensions}

We expect that any or all of the following possible future extensions would be compatible with the RVWMO memory model:

\begin{itemize}
  \item `V' vector ISA extensions
  \item A transactional memory subset of the `T' ISA extension
  \item `J' JIT extension
  \item Native encodings for {\tt l\{b|h|w|d\}.aq}/{\tt s\{b|h|w|d\}.rl}
  \item Fences limited to certain addresses
  \item Cache writeback/flush/invalidate/etc.\@ instructions
\end{itemize}

\chapter{Formal Memory Model Specifications}

\begin{commentary}
  To facilitate formal analysis of RVWMO, we present a set of formalizations in this chapter.  Any discrepancies are unintended; the expectation is that the models will describe exactly the same sets of legal behaviors, pending some memory model changes that have not quite been added to all of the formalizations yet.

  As such, these formalizations should be considered snapshots from some point in time during the development process rather than finalized specifications.

  At this point, no individual formalization is considered authoritative, but we may designate one as such in collaboration with the ISA specification and/or formalization task groups.
\end{commentary}

\section{Formal Axiomatic Specification in Alloy}
\label{sec:alloy}

\textcolor{red}{FIXME: the Alloy model is out of date!}

\lstdefinelanguage{alloy}{
  morekeywords={abstract, sig, extends, pred, fun, fact, no, set, one, lone, let, not, all, iden, some, run, for},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{green!40!black},
  keywordstyle=\color{blue!40!black},
  moredelim=**[is][\color{red}]{@}{@},
  escapeinside={!}{!},
}
\lstset{language=alloy}
\lstset{aboveskip=0pt}
\lstset{belowskip=0pt}

We present a formal specification of the RVWMO memory model in Alloy (\url{http://alloy.mit.edu}).
This model is available online at \url{https://github.com/daniellustig/riscv-memory-model}.

\begin{figure}[h!]
  {
  \tt\bfseries\centering\footnotesize
  \begin{lstlisting}
////////////////////////////////////////////////////////////////////////////////
// =RISC-V RVWMO axioms=

// Preserved Program Order
fun ppo : Event->Event {
  // same-address ordering
  po_loc :> Store

  // explicit synchronization
  + ppo_fence
  + Load.aq <: ^po
  + ^po :> Store.rl
  + Store.aq.rl <: ^po :> Load.aq.rl
  + ^po :> Load.sc
  + Store.sc <: ^po

  // dependencies
  + addr
  + data
  + ctrl :> Store
  + (addr+data).successdep

  // RDW
  + (po_loc & (fre.rfe))

  // pipeline dependency artifacts
  + (addr+data).rfi
  + addr.^po :> Store
  + ctrl.(FenceI <: ^po)
  + addr.^po.(FenceI <: ^po)
}

// the global memory order respects preserved program order
fact { ppo in gmo }
\end{lstlisting}}
  \caption{The RVWMO memory model formalized in Alloy (1/4: PPO)}
  \label{fig:alloy1}
\end{figure}
\begin{figure}[h!]
  {
  \tt\bfseries\centering\footnotesize
  \begin{lstlisting}
// Load value axiom
fun candidates[r: Load] : set Store {
  (r.~gmo & Store & same_addr[r]) // writes preceding r in gmo
  + (r.^~po & Store & same_addr[r]) // writes preceding r in po
}

fun latest_among[s: set Event] : Event { s - s.~gmo }

pred LoadValue {
  all w: Store | all r: Load |
    w->r in rf <=> w = latest_among[candidates[r]]
}

fun after_reserve_of[r: Load] : Event { latest_among[r + r.~rf].gmo }

pred Atomicity {
  all r: Store.~rmw |               // starting from the read r of an atomic,
    no x: Store & same_addr[r + r.rmw] | // there is no write x to the same addr
      x not in same_hart[r]         // from a different hart, such that
      and x in after_reserve_of[r]  // x follows (the write r reads from) in gmo
      and r.rmw in x.gmo            // and r follows x in gmo
}

pred RISCV_mm { LoadValue and Atomicity }
\end{lstlisting}}
  \caption{The RVWMO memory model formalized in Alloy (2/4: Axioms)}
  \label{fig:alloy2}
\end{figure}
\begin{figure}[h!]
  {
  \tt\bfseries\centering\footnotesize
  \begin{lstlisting}
////////////////////////////////////////////////////////////////////////////////
// Basic model of memory

sig Hart {  // hardware thread
  start : one Event
}
sig Address {}
abstract sig Event {
  po: lone Event // program order
}

abstract sig MemoryEvent extends Event {
  address: one Address,
  aq: lone MemoryEvent, // opcode bit
  rl: lone MemoryEvent, // opcode bit
  sc: lone MemoryEvent, // for AMOs with .aq and .rl, to distinguish from lr/sc
  gmo: set MemoryEvent   // global memory order
}
sig Load extends MemoryEvent {
  addr: set Event,
  ctrl: set Event,
  data: set Store,
  successdep: set Event,
  rmw: lone Store
}
sig Store extends MemoryEvent {
  rf: set Load
}
sig Fence extends Event {
  pr: lone Fence, // opcode bit
  pw: lone Fence, // opcode bit
  sr: lone Fence, // opcode bit
  sw: lone Fence  // opcode bit
}
sig FenceI extends Event {}

// FENCE PPO
fun FencePRSR : Fence { Fence.(pr & sr) }
fun FencePRSW : Fence { Fence.(pr & sw) }
fun FencePWSR : Fence { Fence.(pw & sr) }
fun FencePWSW : Fence { Fence.(pw & sw) }

fun ppo_fence : MemoryEvent->MemoryEvent {
    (Load  <: ^po :> FencePRSR).(^po :> Load)
  + (Load  <: ^po :> FencePRSW).(^po :> Store)
  + (Store <: ^po :> FencePWSR).(^po :> Load)
  + (Store <: ^po :> FencePWSW).(^po :> Store)
}
\end{lstlisting}}
  \caption{The RVWMO memory model formalized in Alloy (3/4: model of memory)}
  \label{fig:alloy3}
\end{figure}
\begin{figure}[h!]
  {
  \tt\bfseries\centering\footnotesize
  \begin{lstlisting}
// auxiliary definitions
fun RFInit : Load { Load - Store.rf }

fun po_loc : Event->Event { ^po & address.~address }
fun same_hart[e: Event] : set Event { e + e.^~po + e.^po }
fun same_addr[e: Event] : set Event { e.address.~address }

// basic facts about well-formed execution candidates
fact { acyclic[po] }
fact { all e: Event | one e.*~po.~start }  // each event is in exactly one hart
fact { rf.~rf in iden } // each read returns the value of only one write
fact { total[gmo, MemoryEvent] } // gmo is a total order over all MemoryEvents

//rf
fact { rf in address.~address }
fun internal : Event->Event { Event <: (*po + *~po) :> Event }
fun rfi : Store->Load { rf & internal }
fun rfe : Store->Load { rf - internal }
fun fr : Load->Store {
  ((~rf.gmo) + (RFInit <: Event->Event)) & (address.~address :> Store)
}
fun fre : Load->Store { fr - internal }

//dep
fact { addr + ctrl + data in ^po }
fact { successdep in (Store.~rmw) <: ^po }
fact { ctrl.*po in ctrl }
fact { rmw in ^po }

// to unclutter the display a bit
fun mo : MemoryEvent->MemoryEvent {
  gmo - (gmo.gmo)
}

////////////////////////////////////////////////////////////////////////////////
// =Opcode encoding restrictions=

// opcode bits are either set (encoded, e.g., as f.pr in iden) or unset
// (f.pr not in iden).  The bits cannot be used for anything else
fact { pr + pw + sr + sw + aq + rl + sc in iden }
fact { sc in aq & rl }
fact { Load.sc.rmw in Store.sc and Store.sc.~rmw in Load.sc }

// Fences must have either pr or pw set, and either sr or sw set
fact { Fence in Fence.(pr + pw) & Fence.(sr + sw) }

// there is no write-acquire, but there is write-strong-acquire
fact { Store.aq in Store.aq.rl }
fact { Load.rl in Load.aq.rl }

////////////////////////////////////////////////////////////////////////////////
// =Alloy shortcuts=
pred acyclic[rel: Event->Event] { no iden & ^rel }
pred total[rel: Event->Event, bag: Event] {
  all disj e, e': bag | e->e' in rel + ~rel
  acyclic[rel]
}
\end{lstlisting}}
  \caption{The RVWMO memory model formalized in Alloy (4/4: Auxiliaries)}
  \label{fig:alloy4}
\end{figure}


\clearpage
\section{Formal Axiomatic Specification in Herd}

The tool \textsf{herd} takes a memory model and a litmus test as input and simulates the execution of the test on top of the memory model. Memory models are written in the domain specific language \textsc{Cat}. This section provides two \textsc{Cat} memory model of RVWMO. The first model, Figure~\ref{fig:herd2}, follows the \emph{global memory order}, Section~\ref{sec:memorymodel}, definition of~RVWMO, as much as is possible for a \textsc{Cat} model. The second model, Figure~\ref{fig:herd3}, is an equivalent, more efficient, partial order based RVWMO model.

The simulator~\textsf{herd} is part of the \textsf{diy} tool suite --- see \url{http://diy.inria.fr} for software and documentation. The models and more are available online at~\url{http://diy.inria.fr/cats7/riscv/}.

\begin{figure}[h!]
  {
  \tt\bfseries\centering\footnotesize
  \begin{lstlisting}
(*************)
(* Utilities *)
(*************)

(* All fence relations *)
let fence.r.r = [R];fencerel(Fence.r.r);[R]
let fence.r.w = [R];fencerel(Fence.r.w);[W]
let fence.r.rw = [R];fencerel(Fence.r.rw);[M]
let fence.w.r = [W];fencerel(Fence.w.r);[R]
let fence.w.w = [W];fencerel(Fence.w.w);[W]
let fence.w.rw = [W];fencerel(Fence.w.rw);[M]
let fence.rw.r = [M];fencerel(Fence.rw.r);[R]
let fence.rw.w = [M];fencerel(Fence.rw.w);[W]
let fence.rw.rw = [M];fencerel(Fence.rw.rw);[M]
let fence = 
  fence.r.r | fence.r.w | fence.r.rw |
  fence.w.r | fence.w.w | fence.w.rw |
  fence.rw.r | fence.rw.w | fence.rw.rw

(* Same address, no W to the same address in-between *)
let po-loc-no-w = po-loc \ (po-loc?;[W];po-loc)
(* Read same write *)
let rsw = rf^-1;rf
(* Acquire, or stronger  *)
let AQ = Acq|AcqRel
(* Release or stronger *)
and RL = RelAcqRel
(* All RCsc *)
let RCsc = Acq|Rel|AcqRel
(* Amo events are both R and W *)
let AMO = R & W
(* Add "artificial" data dependencies, ie paired lr/sc *)
let data = data | rmw

(*************)
(* ppo rules *)
(*************)

(* Overlapping-Address Orderings *)
let r1 = [M];po-loc;[W]
and r2 = ([R];po-loc-no-w;[R]) \ rsw
and r3 = [AMO];po-loc;[M]
(* Explicit Synchronization *)
and r4 = fence
and r5 = [AQ];po;[M]
and r6 = [M];po;[RL]
and r7 = [RCsc];po;[RCsc]
(* Syntactic Dependencies *)
and r8 = [M];addr;[M]
and r9 = [M];data;[W]
and r10 = [M];ctrl;[W]
(* Pipeline Dependencies *)
and r11 = [R];(addr|data);[W];rfi;[R]
and r12 = [R];addr;[M];po;[W]

let ppo = r1 | r2 | r3 | r4 | r5 | r6 | r7 | r8 | r9 | r10 | r11 | r12
\end{lstlisting}
  }
  \caption{{\tt riscv-defs.cat}, a herd definition of preserved program order (1/3)}
  \label{fig:herd1}
\end{figure}

\begin{figure}[ht!]
  {
  \tt\bfseries\centering\footnotesize
  \begin{lstlisting}
Total

(* Notice that herd has defined its own rf relation *)

(* Define ppo *)
include "riscv-defs.cat"

(********************************)
(* Generate global memory order *)
(********************************)

let gmo0 = (* precursor: ie build gmo as an total order that include gmo0 *)
  loc & (W\FW) * FW | # Final write after any write to the same location
  ppo |               # ppo compatible
  rfe                 # includes herd external rf (optimisation)

(* Walk over all linear extensions of gmo0 *)
with  gmo from linearisations(M\IW,gmo0)

(* Add initial writes upfront -- convenient for computing rfGMO *)
let gmo = gmo | loc & IW * (M\IW)

(**********)
(* Axioms *)
(**********)

(* Compute rf according to the load value axiom, aka rfGMO *)
let WR = loc & ([W];(gmo|po);[R])
let rfGMO = WR \ (loc&([W];gmo);WR)

(* Check equality of herd rf and of rfGMO *)
empty (rf\rfGMO)|(rfGMO\rf) as RfCons

(* Atomicity axiom *)
let infloc = (gmo & loc)^-1
let inflocext = infloc & ext
let winside  = (infloc;rmw;inflocext) & (infloc;rf;rmw;inflocext) & [W]
empty winside as Atomic
\end{lstlisting}
  }
  \caption{{\tt riscv.cat}, a herd version of the RVWMO memory model (2/3)}
  \label{fig:herd2}
\end{figure}

\begin{figure}[h!]
  {
  \tt\bfseries\centering\footnotesize
  \begin{lstlisting}
Partial

(***************)
(* Definitions *)
(***************)

(* Define ppo *)
include "riscv-defs.cat"

(* Compute coherence relation *)
include "cos-opt.cat"

(**********)
(* Axioms *)
(**********)

(* Sc per location *)
acyclic co|rf|fr|po-loc as Coherence

(* Main model axiom *)
acyclic co|rfe|fr|ppo as Model

(* Atomicity axiom *)
empty rmw & (fre;coe) as Atomic
\end{lstlisting}
  }
  \caption{{\tt riscv.cat}, an alternative herd presentation of the RVWMO memory model (3/3)}
  \label{fig:herd3}
\end{figure}

%% Operational Memory Model
\clearpage
\input{operational-memory-model.tex}
